#include "include/background.hpp"
#include "include/colorS.hpp"
#include "include/loadAssets.hpp"
#include <iterator>
#include "include/collapse.hpp"

#include <iostream>
#include <curses.h>


//constexpr char NAME_OF_THIS_FILE[] = "background.cpp";


backgroundData::backgroundType backgroundData::loadAndInitialiseBackground
(const char bgFileName []) const
{
  std::string rawLevelBackground {};
  backgroundType background;
    
  loadFileIntoString(bgFileName, rawLevelBackground,
		     "trying to read .background.lev file");
  initialiseBackground(false, bgFileName, rawLevelBackground, background);
  /* This will result in a deep copy when this function is called from the
     constructor. However this only happens once per level load. */
  return background;
}


void backgroundData::initialiseBackground
(const bool rawData, const char bgFileName [], const std::string & bgData,
 backgroundType & background) const
{
  
  if(rawData)
    {			/* This is probably a file generated by the
			   level editor. */
      // /* Read background header, which should contain a 2-tuple which
      //    specifies the size of the chunks in the file in their y and x
      //    dimensions respectively. We don't technically need this number
      //    since the yHeight and xWidth (which are defined in utils.hpp) are
      //    used for this purpose. However we might change this in the future
      //    and having these numbers in level background files make it more
      //    explicit when looking at those files. This should also allow for
      //    the possibility of levels with a smaller view port than that of
      //    the window. Although changes will almost certainly have to be made
      //    to the code to support that feature. */
      // const yx chunkSize {getChunkSize(bgData)};
      yx chunkCoord {};
      std::string chunk {};
      backgroundChunk rawChunk {};
      std::string::const_iterator buffPos {std::begin(bgData)};
	  
      while(true)
	{
	  ssize_t chunksReadIn {};
	  /* Each chunk should have a header that contains it's coordinates
	     in the level. The unit of the coordinates should be chunks. So
	     for a chunk that starts at (0, 170) in character coordinates
	     (assuming the size of chunks for this file are 170 in the x
	     dimension), the coordinate in the header would be (0, 1) and
	     for (0, 340) it would be (0, 2), etc... */
	  if(getChunkCoordinate(bgData, buffPos,
				concat("trying to read coord no. ",
				       chunksReadIn, " from background.lev "
				       "file \"", bgFileName, "\""),
				chunkCoord))
	    {
	      // Get chunk from background data read from file.
	      // Collapse chunk and return in rawChunk.
	      // collapse(chunk, rawChunk);

	      /* Store rawChunk in this.background with a key that should be
		 calculated according to the following:
		 Concatenate (y / maxyx.y) and (x / maxyx.y) and use as
		 index into map. Then
		 (y % (maxyx.y * 3)) * maxyx.x + (x % (maxyx.x * 3)) can
		 be used to index into the backgroundChunk returned from
		 the map (as the stage 1 draw buffer will be 3 by 3
		 chunks.)
	      */

	      chunksReadIn++;
	      // GetChunk() clears it's argument (chunk).
	      rawChunk.clear();
	    }
	  else
	    {
	      break;
	    }
	}
    }
  else
    {
      // const yx chunkSize {getChunkSize(bgData)};
      yx chunkCoord {};
      std::string chunk {};
      backgroundChunk rawChunk {};
      std::string::const_iterator buffPos {std::begin(bgData)};
      ssize_t chunksReadIn {};

      while(true)
	{
	  /* Each chunk should have a header that contains it's coordinates
	     in the level. The unit of the coordinates should be chunks. So
	     for a chunk that starts at (0, 170) in character coordinates
	     (assuming the size of chunks for this file are 170 in the x
	     dimension), the coordinate in the header would be (0, 1) and
	     for (0, 340) it would be (0, 2), etc... */
	  if(getChunkCoordinate(bgData, buffPos,
				concat("trying to read coord no. ",
				       chunksReadIn, " from background.lev "
				       "file \"", bgFileName, "\""),
				chunkCoord))
	    {
	      skipSpaceUpToNextLine
		(bgData, buffPos,
		 concat("Error: trying to read chunk no. ", chunksReadIn,
			". Expected '\\n' after reading chunk coordinate "
			"from background.lev file \"", bgFileName, "\". "
			"Encountered other character or EOF."));
	      // Get chunk from background data read from file.
	      getChunk(bgData, buffPos,
		       concat("trying to read in chunk no. ", chunksReadIn,
			      " from background.lev file \"", bgFileName,
			      "\"."), chunk, maxyx);
	      // Collapse chunk and return in rawChunk.
	      collapse(chunk, rawChunk);
	      verifyCollapsedChunkSize(rawChunk, chunksReadIn, true);
	      insertChunk(chunkCoord, rawChunk, chunksReadIn, bgFileName,
			  background);

	      chunksReadIn++;
	      // GetChunk() clears it's argument (chunk).
	      rawChunk.clear();
	    }
	  else
	    {
	      break;
	    }
	}
    }
}


// bool backgroundData::getChunkCoordinate(const std::string & bgData,
// 			std::string::const_iterator & buffPos,
// 			const std::string & eMsg, yx & chunkCoord) const
// {
//   if(buffPos != std::end(bgData))
//     {
//       readSingleCoordSectionInNNumbersNoSkpSp
// 	(bgData, buffPos, eMsg, &chunkCoord);

//       return true;
//     }
//   else
//     {
//       return false;
//     }
// }


// void backgroundData::getChunk(const std::string & bgData,
// 	      std::string::const_iterator & buffPos, const std::string & eMsg,
// 	      std::string & chunk) const
// {
//   chunk.clear();

//   int lnCount {};
//   for( ; lnCount < maxyx.y && buffPos != std::end(bgData); )
//     {
//       char newCh {};
//       newCh = *buffPos++;
//       chunk += newCh;
//       lnCount += (newCh == '\n' ? 1: 0);
//     }
//   if(lnCount != maxyx.y)
//     {
//       exit(eMsg, ERROR_BACKGROUND);
//     }
// }


void backgroundData::verifyCollapsedChunkSize
(const backgroundChunk & rawChunk, const ssize_t chunksReadIn,
 const bool attemptedCompression) const
{
  if(rawChunk.size() != (size_t)(maxyx.y * maxyx.x))
    {      
      exit(concat
	   ("Error: chunk no. ", chunksReadIn, " is the wrong size (",
	    rawChunk.size(), ")",
	    (attemptedCompression ? " after being compressed.": "."),
	    "Expected size of ",
	    maxyx.y * maxyx.x, " (", maxyx.y, " * ", maxyx.x, ")."),
	   ERROR_BACKGROUND);
    }
}


std::string inline backgroundData::createChunkCoordKey(const yx coord) const
{
    /* ',' must be included to delineate between the y and x
     coordinates. */
    return concat("", coord.y, ",", coord.x);
}


void backgroundData::insertChunk
(const yx coord, const backgroundChunk & rawChunk, const ssize_t chunksReadIn,
 const char bgFileName [], backgroundType & background) const
{
  /* Store rawChunk in this.background with a key that should be
     calculated according to the following:
     Concatenate (y / maxyx.y) and (x / maxyx.y) and use as
     index into map. Then
     (y % (maxyx.y * 3)) * maxyx.x + (x % (maxyx.x * 3)) can
     be used to index into the backgroundChunk returned from
     the map (as the stage 1 draw buffer will be 3 by 3
     chunks.)
  */
  const std::string key
    {createChunkCoordKey(coord)};
  if(background.insert
     (std::pair<std::string, backgroundChunk>
      (key, rawChunk)).second == false)
    {
      exit(concat
	   ("Error: duplicate chunk coordinate (",
	    key, ") found when loading chunk no. ",
	    chunksReadIn, " from file \"", bgFileName, "\"."),
	   ERROR_BACKGROUND);
    }
}


/*void backgroundData::checkForChunk(const yx coord)
{
}*/


/*bool backgroundData::getChunk
    (const yx & coord, backgroundData::backgroundChunk * chunk) const
{
  const std::string key {createChunkCoordKey(coord)};
  backgroundChunk & ret {};
  
  // try
  //   {
  //     ret = background.at(key);
  //   }
  // catch()
  //   {
      
  //   }
  return ret;
  }*/
