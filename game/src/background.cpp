#include "include/background.hpp"
#include "include/colorS.hpp"
#include "include/loadAssets.hpp"
#include <iterator>
#include "include/collapse.hpp"

#include <iostream>
#include <curses.h>


constexpr char NAME_OF_THIS_FILE[] = "background.cpp";


/* First checks if buffPos is in range. Returns false if it is not. Otherwise
   attempts to read the coordinates into chunkCoord. If this succeeds returns
   true (with chunkCoord being set to the coordinates read.) If there is a
   failure in reading the coordinates then the program will be aborted with eMsg
   being displayed. */
bool backgroundData::getChunkCoordinate(const std::string & bgData,
			std::string::const_iterator & buffPos,
			const std::string & eMsg, yx & chunkCoord)
{
  if(buffPos != std::end(bgData))
    {
      readSingleCoordSectionInNNumbersNoSkpSp
	(bgData, buffPos, eMsg, &chunkCoord);

      return true;
    }
  else
    {
      return false;
    }
}


void backgroundData::getChunk(const std::string & bgData,
	      std::string::const_iterator & buffPos, const std::string & eMsg,
	      std::string & chunk)
{
  chunk.clear();

  int lnCount {};
  for( ; lnCount < maxyx.y && buffPos != std::end(bgData); )
    {
      char newCh {};
      newCh = *buffPos++;
      chunk += newCh;
      lnCount += (newCh == '\n' ? 1: 0);
    }
  if(lnCount != maxyx.y)
    {
      exit(eMsg, ERROR_BACKGROUND);
    }
}


void backgroundData::verifyCollapsedChunkSize(const backgroundChunk & rawChunk,
					      const ssize_t chunksReadIn,
					      const bool attemptedCompression)
{
  if(rawChunk.size() != (maxyx.y * maxyx.x))
    {      
      exit(concat
	   ("Error: chunk no. ", chunksReadIn, " is the wrong size (",
	    rawChunk.size(), ")",
	    (attemptedCompression ? " after being compressed.": "."),
	    "Expected size of ",
	    maxyx.y * maxyx.x, " (", maxyx.y, " * ", maxyx.x, ")."),
	   ERROR_BACKGROUND);
    }
}


void backgroundData::initialiseBackgroundData
    (const bool rawData, const char bgFileName [], const std::string & bgData)
{
  if(backgroundModifiable)
    {
      if(rawData)
	{			/* This is probably a file generated by the
				   level editor. */
	  // /* Read background header, which should contain a 2-tuple which
	  //    specifies the size of the chunks in the file in their y and x
	  //    dimensions respectively. We don't technically need this number
	  //    since the yHeight and xWidth (which are defined in utils.hpp) are
	  //    used for this purpose. However we might change this in the future
	  //    and having these numbers in level background files make it more
	  //    explicit when looking at those files. This should also allow for
	  //    the possibility of levels with a smaller view port than that of
	  //    the window. Although changes will almost certainly have to be made
	  //    to the code to support that feature. */
	  // const yx chunkSize {getChunkSize(bgData)};
	  yx chunkCoord {};
	  std::string chunk {};
	  backgroundChunk rawChunk {};
	  std::string::const_iterator buffPos {std::begin(bgData)};
	  
	  while(true)
	    {
	      ssize_t chunksReadIn {};
	      /* Each chunk should have a header that contains it's coordinates
		 in the level. The unit of the coordinates should be chunks. So
		 for a chunk that starts at (0, 170) in character coordinates
		 (assuming the size of chunks for this file are 170 in the x
		 dimension), the coordinate in the header would be (0, 1) and
		 for (0, 340) it would be (0, 2), etc... */
	      if(getChunkCoordinate(bgData, buffPos,
				    concat("trying to read coord no. ",
					   chunksReadIn, " from background.lev "
					   "file \"", bgFileName, "\""),
				    chunkCoord))
	      {
		// Get chunk from background data read from file.
		// Collapse chunk and return in rawChunk.
		// collapse(chunk, rawChunk);

		/* Store rawChunk in this.background with a key that should be
		   calculated according to the following:
		   Concatenate (y / maxyx.y) and (x / maxyx.y) and use as
		   index into map. Then
		   (y % (maxyx.y * 3)) * maxyx.x + (x % (maxyx.x * 3)) can
		   be used to index into the backgroundChunk returned from
		   the map (as the stage 1 draw buffer will be 3 by 3
		   chunks.)
		*/

		chunksReadIn++;
		// GetChunk() clears it's argument (chunk).
		rawChunk.clear();
	      }
	      else
		{
		  break;
		}
	    }
	}
      else
	{
	  // const yx chunkSize {getChunkSize(bgData)};
	  yx chunkCoord {};
	  std::string chunk {};
	  backgroundChunk rawChunk {};
	  std::string::const_iterator buffPos {std::begin(bgData)};
	  ssize_t chunksReadIn {};

	  while(true)
	    {
	      /* Each chunk should have a header that contains it's coordinates
		 in the level. The unit of the coordinates should be chunks. So
		 for a chunk that starts at (0, 170) in character coordinates
		 (assuming the size of chunks for this file are 170 in the x
		 dimension), the coordinate in the header would be (0, 1) and
		 for (0, 340) it would be (0, 2), etc... */
	      if(getChunkCoordinate(bgData, buffPos,
				    concat("trying to read coord no. ",
					   chunksReadIn, " from background.lev "
					   "file \"", bgFileName, "\""),
				    chunkCoord))
		{
		  /*
		    Error: expected "(" to denote the start of single
		    coordinate section (with natural numbers (without
		    skipping space up until the coordinate)) when trying to
		    read coord no. 0 from background.lev file
		    "assets/level1/level1.backgound.lev". Encountered "
		   */
		  skipSpaceUpToNextLine
		    (bgData, buffPos,
		     concat("Error: trying to read chunk no. ", chunksReadIn,
			    ". Expected '\\n' after reading chunk coordinate "
			    "from background.lev file \"", bgFileName, "\". "
			    "Encountered other character or EOF."));
		  // Get chunk from background data read from file.
		  getChunk(bgData, buffPos,
			   concat("Error: reading in chunk no. ", chunksReadIn,
				  " from background.lev file \"", bgFileName,
				  "\""), chunk);
		  // Collapse chunk and return in rawChunk.
		  collapse(chunk, rawChunk);

		  // endwin();
		  // for(auto c: rawChunk)
		  //   {
		  //     std::cout<<(char)c;
		  //   }
		  // std::cout<<std::endl;
		  // exit(-1);
		  
		  verifyCollapsedChunkSize(rawChunk, chunksReadIn, true);

		  /* Store rawChunk in this.background with a key that should be
		     calculated according to the following:
		     Concatenate (y / maxyx.y) and (x / maxyx.y) and use as
		     index into map. Then
		     (y % (maxyx.y * 3)) * maxyx.x + (x % (maxyx.x * 3)) can
		     be used to index into the backgroundChunk returned from
		     the map (as the stage 1 draw buffer will be 3 by 3
		     chunks.)
		  */

		  chunksReadIn++;
		  // GetChunk() clears it's argument (chunk).
		  rawChunk.clear();
		}
	      else
		{
		  break;
		}
	    }
	}
    }
  else
    {
      exit("Error multiple calls to backgroundData.initialiseBackgroundData()"
	   " are not allowed.", ERROR_BAD_LOGIC);
    }
  backgroundModifiable = false;
}
