#include "include/background.hpp"
#include "include/colorS.hpp"
#include "include/collapse.hpp"
#include <cstdlib>


void backgroundData::loadAndInitialiseBackground()
{
  std::string rawLevelBackground {};
    
  loadFileIntoString
    (fileName, rawLevelBackground,
     concat("trying to read ", BACKGROUND_FILE_EXTENSION, " file"));
  initialiseBackground(false, rawLevelBackground, chunkMap);
}


void backgroundData::initialiseBackground
(const bool rawData, const std::string & bgData,
 chunkMapType & background)
{
  
  if(rawData)
    {
      /* This is probably a file generated by the level editor. */
      // /* Read background header, which should contain a 2-tuple which
      //    specifies the size of the chunks in the file in their y and x
      //    dimensions respectively. We don't technically need this number
      //    since the yHeight and xWidth (which are defined in utils.hpp) are
      //    used for this purpose. However we might change this in the future
      //    and having these numbers in level background files make it more
      //    explicit when looking at those files. This should also allow for
      //    the possibility of levels with a smaller view port than that of
      //    the window. Although changes will almost certainly have to be made
      //    to the code to support that feature. */
      // const yx chunkSize {getChunkSize(bgData)};
      yx chunkCoord {};
      chunkType rawChunk {};
      std::string::const_iterator buffPos {std::begin(bgData)};
	  
      while(true)
	{
	  ssize_t chunksReadIn {};
	  /* Each chunk should have a header that contains it's coordinates
	     in the level. The unit of the coordinates should be chunks. So
	     for a chunk that starts at (0, 170) in character coordinates
	     (assuming the size of chunks for this file are 170 in the x
	     dimension), the coordinate in the header would be (0, 1) and
	     for (0, 340) it would be (0, 2), etc... */
	  if(getChunkCoordinate
	     (bgData, buffPos,
	      concat("trying to read coord no. ", chunksReadIn, " from ",
		     BACKGROUND_FILE_EXTENSION, " file \"", fileName, "\""),
	      chunkCoord))
	    {
	      // Get chunk from background data read from file.
	      // Collapse chunk and return in rawChunk.
	      // collapse(chunk, rawChunk);

	      /* Store rawChunk in this.background with a key that should be
		 calculated according to the following:
		 Concatenate (y / chunkSize.y) and (x / chunkSize.y) and use as
		 index into map. Then
		 (y % (chunkSize.y * 3)) * chunkSize.x + (x % (chunkSize.x * 3))
		 can be used to index into the chunkType returned from
		 the map (as the stage 1 draw buffer will be 3 by 3
		 chunks.)
	      */

	      chunksReadIn++;
	      // GetChunk() clears it's argument (chunk).
	      rawChunk.clear();
	    }
	  else
	    {
	      break;
	    }
	}
    }
  else
    {
      yx chunkCoord {};
      std::string chunk {};
      chunkType rawChunk {};
      std::string::const_iterator buffPos {std::begin(bgData)};
      ssize_t chunksReadIn {};

      while(true)
	{
	  /* Each chunk should have a header that contains it's coordinates
	     in the level. The unit of the coordinates should be chunks. So
	     for a chunk that starts at (0, 170) in character coordinates
	     (assuming the size of chunks for this file are 170 in the x
	     dimension), the coordinate in the header would be (0, 1) and
	     for (0, 340) it would be (0, 2), etc... */
	  if(getChunkCoordinate
	     (bgData, buffPos,
	      concat("trying to read coord no. ", chunksReadIn, " from ",
		     BACKGROUND_FILE_EXTENSION, " file \"", fileName, "\""),
	      chunkCoord))
	    {
	      skipSpaceUpToNextLine
		(bgData, buffPos,
		 concat("Error: trying to read chunk no. ", chunksReadIn,
			". Expected '\\n' after reading chunk coordinate "
			"from ", BACKGROUND_FILE_EXTENSION, " file \"",
			fileName, "\". Encountered other character or EOF."));
	      // Get chunk from background data read from file.
	      getChunk(bgData, buffPos,
		       concat("trying to read in chunk no. ", chunksReadIn,
			      " from ", BACKGROUND_FILE_EXTENSION, " file \"",
			      fileName, "\"."), chunk, chunkSize);
	      // Collapse chunk and return in rawChunk.
	      collapse(chunk, rawChunk);
	      verifyCollapsedChunkSize(rawChunk, chunksReadIn, true);
	      insertChunk(chunkCoord, rawChunk, chunksReadIn, fileName,
			  background);

	      chunksReadIn++;
	      // GetChunk() clears it's argument (chunk).
	      rawChunk.clear();
	    }
	  else
	    {
	      break;
	    }
	}
    }
}


void backgroundData::verifyCollapsedChunkSize
(const chunkType & rawChunk, const ssize_t chunksReadIn,
 const bool attemptedCompression) const
{
  if(rawChunk.size() != (size_t)(chunkSize.y * chunkSize.x))
    {      
      exit(concat
	   ("Error: chunk no. ", chunksReadIn, " is the wrong size (",
	    rawChunk.size(), ")",
	    (attemptedCompression ? " after being decompressed. ": "."),
	    "Expected size of ", chunkSize.y * chunkSize.x, " (",
	    chunkSize.y, " * ", chunkSize.x, ")."),
	   ERROR_BACKGROUND);
    }
}
