#include "include/background.hpp"
#include "include/colorS.hpp"
#include "include/loadAssets.hpp"
#include <iterator>
//#include "include/collapse.hpp"


constexpr char NAME_OF_THIS_FILE[] = "background.cpp";


/* Uses: void readSingleCoordSectionInNNumbersOnSameLineAsPos
   (const std::string & buff, std::string::const_iterator & buffPos,
   const std::string & eMsg, yx & coord)
   from loadAssets.hpp / .cpp. First checks if buffPos is in range. If a it is
   calls readSingleCoordSectionInNNumbersOnSameLineAsPos, which will abort the
   program with eMsg if no coordinate is found. Otherwise returns false. However
   if readSingleCoordSectionInNNumbersOnSameLineAsPos is called and doesn't
   abort the program then chunkCoord will hold the value read. */
bool getChunkCoordinate(const std::string & bgData,
			std::string::const_iterator & buffPos,
			const std::string & eMsg, yx & chunkCoord)
{
  if(buffPos != std::end(bgData))
    {
      readSingleCoordSectionInNNumbersOnSameLineAsPos
	(bgData, buffPos, eMsg, &chunkCoord);
    }
  else
    {
      return false;
    }
}


void backgroundData::initialiseBackgroundData(const bool rawData,
					      const std::string & bgData)
{
  if(backgroundModifiable)
    {
      if(rawData)
	{			/* This is probably a file generated by the
				   level editor. */
	  // /* Read background header, which should contain a 2-tuple which
	  //    specifies the size of the chunks in the file in their y and x
	  //    dimensions respectively. We don't technically need this number
	  //    since the yHeight and xWidth (which are defined in utils.hpp) are
	  //    used for this purpose. However we might change this in the future
	  //    and having these numbers in level background files make it more
	  //    explicit when looking at those files. This should also allow for
	  //    the possibility of levels with a smaller view port than that of
	  //    the window. Although changes will almost certainly have to be made
	  //    to the code to support that feature. */
	  // const yx chunkSize {getChunkSize(bgData)};
	  yx chunkCoord {};
	  std::string rawChunk {};
	  std::vector<int> chunk {};
	  std::string::const_iterator buffPos {std::begin(bgData)}
	  
	  while(true)
	    {
	      /* Each chunk should have a header that contains it's coordinates
		 in the level. The unit of the coordinates should be chunks. So
		 for a chunk that starts at (0, 170) in character coordinates
		 (assuming the size of chunks for this file are 170 in the x
		 dimension), the coordinate in the header would be (0, 1) and
		 for (0, 340) it would be (0, 2), etc... */
	      if(getChunkCoordinate(bgData, buffPos, chunkCoord));
	      {
		// Get chunk from background data read from file.
		getChunk(bgData, rawChunk);
		// Collapse rawChunk and return in chunk.
		collapse(rawChunk, chunk);

		/* Store chunk in this.background with a key that should be
		   calculated according to the following:
		   Concatenate (y / maxyx.y) and (x / maxyx.y) and use as
		   index into map. Then
		   (y % (maxyx.y * 3)) * maxyx.x + (x % (maxyx.x * 3)) can
		   be used to index into the backgroundChunk returned from
		   the map (as the stage 1 draw buffer will be 3 by 3
		   chunks.)
		*/
		
		rawChunk.clear();
		chunk.clear();
	      }
	      else
		{
		  break;
		}
	    }
	}
      else
	{
	}
    }
  else
    {
      exit("Error multiple calls to backgroundData.initialiseBackgroundData()"
	   " are not allowed.", ERROR_BAD_LOGIC);
    }
  backgroundModifiable = false;
}
